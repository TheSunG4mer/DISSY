\section{Week 37 - Communication}

\subsection*{Exercises}
3.1; 3.2; 3.3; 4.1; 4.2; 4.4; 4.5

\Exercise{3.1}
\begin{enumerate}
\item The solution is the clients ask two servers to get a lock, one you get a lock from two servers you are able to write. 
\item Byzantine server error: The server will always hand out is lock, so the system will have the faulty behavior of multiple clients being allowed to write at the same time. 
\item Byzantine client error: The client will get the lock and never release it, deadlocks the system. A client could also overwrite the files completely. This could be okay, depending on the system specification, since a client could be allowed to keep a lock, and overwrite anything they want.
\end{enumerate}
\Exercise{3.2}
\begin{enumerate}
\item
  \textbf{Client}:
\lstinputlisting[language=Golang,firstline=11,lastline=23]{code/exercise_3_2_client.go}
\lstinputlisting[language=Golang,firstline=25,lastline=48]{code/exercise_3_2_client.go}
\textbf{Server}:
\lstinputlisting[language=Golang,firstline=11,lastline=23]{code/exercise_3_2_server.go}
\lstinputlisting[language=Golang,firstline=26,lastline=35]{code/exercise_3_2_server.go}
\lstinputlisting[language=Golang,firstline=37,lastline=72]{code/exercise_3_2_server.go}
\item \textbf{Automatic-Client}:
  \lstinputlisting[language=Golang,firstline=26,lastline=52]{code/exercise_3_2_2.go}
  We do a little bash script
  \begin{lstlisting}[language=bash]
    ./exercise_3_2_server > tmp.txt
    for run in {1..10}; do timeout <time> ./exercise_3_2_2 <ip>:<port> & done
  \end{lstlisting}
  We get that the 10 process did:
  \begin{enumerate}
  \item 130346
  \item 115108
  \item 115517
  \item 120663
  \item 122419
  \item 116656
  \item 121988
  \item 130026
  \item 109901
  \item 120015
  \end{enumerate}
\end{enumerate}
\Exercise{3.3}
\begin{enumerate}
\item Diameter: max distance = 5, run all pairs shortest path.
  Solutions:
  \begin{itemize}
  \item (3, 9)
  \item (4, 6)
  \item (5, 8)
  \item (6, 8)
  \item (7, 3)
  \item (7, 8)
  \item (9, 3)
  \item (10, 8)
  \item (11, 6)
  \item (12, 8)
  \item (15, 2)
  \end{itemize}
\item Connectivity = 1, run min-cut / max-flow, with all edges having weight 1. Here it corresponds to the minimum number of ingoing edges to a node. \vspace{-5mm}
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
      \hline
      P1 & P2 & P3 & P4 & P5 & P6 & P7 & P8 & P9 & P10 & P11 & P12 & P13 & P14 & P15 \\ \hline
      2 & 2 & 1 & 2 & 2 & 2 & 2 & 1 & 1 & 2 & 3 & 2 & 2 & 4 & 2 \\ \hline
    \end{tabular}
  \end{center}
\end{enumerate}
\Exercise{4.1}
\begin{enumerate}
\item Set equivalence, we need to show
  \[ (P_i, m_i) \in \texttt{CausalPast}(P_j, m_j) \Leftrightarrow \texttt{CausalPast}(P_i, m_i) \subseteq \texttt{CausalPast}(P_j, m_j). \]  
    \begin{enumerate}
    \item[\(\Rightarrow\)] Assume
      \[(P_i, m_i) \in \texttt{CausalPast}(P_j, m_j).\]
      For all
      \[(P_k, m_k) \in \texttt{CausalPast}(P_i, m_i),\]
      it must be the case that
      \[(P_k, m_k) \in \texttt{CausalPast}(P_j, m_j)\]
      since the causal past of \(m_j\) is defined as the causal past of \(P_j\) (by step 2.), which includes the causal past of \(m_i\) (by step 3.), since \(m_i\) has been delivered.
      \[\texttt{CausalPast}(P_i, m_i) \subseteq \texttt{CausalPast}(P_j, m_j)\].
    \item[\(\Leftarrow\)] Assume
      \[\texttt{CausalPast}(P_i, m_i) \subseteq \texttt{CausalPast}(P_j, m_j).\]
      We know that
      \[(P_i, m_i) \in \texttt{CausalPast}(P_i, m_i),\]
      thus
      \[(P_i, m_i) \in \texttt{CausalPast}(P_j, m_j)\]
      by the subset inclusion.
    \end{enumerate}
  \item Antisymmetric, for any message \((P',m')\) for which
    \[ (P',m') \in \texttt{CausalPast}(P, m) \]
    and
    \[(P',m') \in \texttt{CausalFuture}(P, m)\]
     (alternatively $(P, m) \in \texttt{CausalPast}(P',m')$ )
     then 
    \[
      (P',m') =  (P,m).
    \]
    The causal past of a message is defined in step 2., i.e. $(P',m') \in \texttt{CausalPast}(P) \cup \{(P,m)\}$ at the time of input.
    For $(P_k,m_k) \neq (P,m)$ this implies $(P',m') \in \texttt{CausalPast}(P)$, implying that $(P',m')$ was input at $P'$ before $(P,m)$.
    However, by $(P, m) \in \texttt{CausalPast}(P',m')$ the input $(P, m)$ must have been given at $P$ before $(P',m')$ was given at $P'$, raising a contradiction.

    Hence, the only element in the intersection is $(P,m)$:
    \[\texttt{CausalPast}(P, m) \cap \texttt{CausalFuture}(P, m) = \{(P,m)\}.\]
\end{enumerate}
\Exercise{4.2}
\begin{enumerate}
\item Transitive
  \[ (P_j, m_j) \hookrightarrow (P_k, m_k) \iff (P_j, m_j) \in \texttt{CausalPast}(P_k, m_k) \]
  \[ (P_i, m_i) \hookrightarrow (P_j, m_j) \iff (P_i, m_i) \in \texttt{CausalPast}(P_j, m_j) \]
  We know \(\texttt{CausalPast}(P_j, m_j) \subseteq \texttt{CausalPast}(P_k, m_k)\) (by ex. 4.1), thus \((P_i, m_i) \in \texttt{CausalPast}(P_k, m_k)\), meaning \((P_i, m_i) \hookrightarrow (P_k, m_k)\).
\item Reflexive \((P_i, m_i) \in \texttt{CausalPast}(P_i, m_i)\) (by step 2.), therefore \((P_i, m_i) \hookrightarrow (P_i, m_i)\).
\item Antisymmetric: 
By definition,
$(P_i, m_i) \in \texttt{CausalPast}(P_j, m_j)$
and 
$(P_i, m_i) \in \texttt{CausalFuture}(P_j, m_j)$.
By antisymmetry (ex. 4.1) the element in this intersection must be $(P_j, m_j)$, thus $(P_i, m_i) = (P_j, m_j)$.
% By subset inclusion (antisymmetry ex. 4.1) both directions we get \(\texttt{CausalPast}(P_i, m_i) = \texttt{CausalPast}(P_j, m_j)\). From this follows
%   \[\texttt{CausalPast}(P_i, m_i) \cap \texttt{CausalFuture}(P_i, m_i)\]
%   is equal to
%   \[\texttt{CausalPast}(P_j, m_j) \cap \texttt{CausalFuture}(P_j, m_j),\]
%   giving us the following equation by the antisymmetry of \texttt{CausalPast} / \texttt{CausalFuture}
%   \[\{ (P_i, m_i) \} = \{ (P_j, m_j) \}\]
%   Therefore \((P_i, m_i) = (P_j, m_j)\).
\end{enumerate}
\Exercise{4.4}
The issue is when two messages are delivered out of order, however \texttt{FIFO2Causal} only accepts when the vector clock is less than or equal to the delivered vector. So this gives us the same restrictions as FIFO delivery. That is the vector clock itself is ensures a FIFO ordering. Formally this can be shown using a simulator on Causal and some environment $\mathcal{Z}$ (however this is not expected in this course).
\Exercise{4.5}
We can see that the lamport clock is true for the $\hookrightarrow$ relation,
\[ (P_i , m_i ) \hookrightarrow (P_j , m_j ) \Rightarrow c(P_i , m_i ) \leq max(c_j, c(P_i , m_i )) = c(P_j , m_j ) \]
and for concurrent messages the ordering solves the issue. We get that we eventually deliver a message, since we can safely deliver concurrent messages in the given order, when we know $c(P_i) \geq c(P_j, m_i)$ for all $P_i$, which happens whenever everyone has received $c(P_j, m_i)$. This can be done by having a local view of all other servers clock, however this need not be send along with messages.

\newpage